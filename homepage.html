<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ziqi</title>
    <style>
        :root {
            --text-color: #ffffff;
            /* æ”¹ä¸ºé’è‰²/è§å…‰è“ï¼Œè¥é€ ç§‘æŠ€ä¸æ·±æµ·æ„Ÿ */
            --accent-color: #00f3ff; 
            --accent-glow: rgba(0, 243, 255, 0.6);
            --bg-deep: #000510;
            /* å¡ç‰‡èƒŒæ™¯æ”¹ä¸ºæ·±è“ç»ç’ƒè´¨æ„Ÿ */
            --card-bg: rgba(0, 20, 40, 0.65);
            --card-border: rgba(0, 243, 255, 0.3);
            --outcome-bg: rgba(0, 243, 255, 0.1);
            --outcome-hover: rgba(0, 243, 255, 0.25);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-deep);
            /* æ·»åŠ æ·±æµ·æ¸å˜èƒŒæ™¯ï¼šé¡¶éƒ¨ç¨äº®ï¼Œåº•éƒ¨æ·±é‚ƒ */
            background: radial-gradient(circle at 50% 0%, #0b2d4f 0%, #000510 80%);
            font-family: 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        #scene-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .node-label {
            position: absolute;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.1s linear; 
            user-select: none;
            will-change: transform;
        }
        
        .node-label.faded {
            opacity: 0.2;
            filter: grayscale(1) blur(2px); /* å¢åŠ æ¨¡ç³Šæ„Ÿ */
            transition: opacity 0.3s;
        }

        .node-root, .node-l1 {
            opacity: 1 !important;
            filter: none !important;
        }

        /* Root Avatar */
        .node-root .avatar {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            border: 3px solid var(--accent-color);
            /* æ›´å¼ºçš„é’è‰²å…‰æ™• */
            box-shadow: 0 0 50px var(--accent-glow), inset 0 0 20px var(--accent-glow);
            object-fit: cover;
            background: #000;
            transition: transform 0.3s;
        }
        .node-root:hover .avatar { transform: scale(1.05); }
        
        .node-root .info {
            margin-top: 18px;
            text-align: center;
            text-shadow: 0 0 10px var(--accent-color);
            background: rgba(0, 10, 20, 0.5);
            padding: 8px 16px;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            border: 1px solid var(--card-border);
        }
        .name { font-size: 1.8rem; font-weight: 700; color: #fff; letter-spacing: 1px; }
        .unit { font-size: 0.95rem; color: #bdeeff; margin-top: 5px; font-weight: 300; }

        /* Level 1 */
        .node-l1 { width: 160px; text-align: center; }
        .dot-l1 {
            width: 22px; height: 22px;
            background: #fff;
            border-radius: 50%;
            margin: 0 auto 10px auto;
            /* å‘å…‰æ ¸å¿ƒ */
            box-shadow: 0 0 25px var(--accent-color), 0 0 10px #fff;
            border: 2px solid var(--accent-color);
        }
        .text-l1 {
            font-size: 1.1rem; color: #fff; font-weight: 600;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.8);
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px; border-radius: 6px;
            backdrop-filter: blur(4px);
            border: 1px solid var(--accent-glow);
        }

        /* Level 2 */
        .node-l2 { width: 120px; text-align: center; }
        .dot-l2 {
            width: 12px; height: 12px;
            background: var(--accent-color);
            border-radius: 50%;
            margin: 0 auto 6px auto; 
            box-shadow: 0 0 15px var(--accent-color);
        }
        .text-l2 {
            font-size: 0.9rem; color: #d0f0ff;
            background: rgba(0, 20, 40, 0.6);
            padding: 4px 10px; border-radius: 4px;
            border: 1px solid rgba(0, 243, 255, 0.2);
        }

        /* Ripple (Water wave effect) */
        .ripple::after {
            content: ''; position: absolute;
            top: 28px; left: 50%;
            transform: translate(-50%, -50%);
            width: 20px; height: 20px;
            border: 1px solid var(--accent-color);
            border-radius: 50%;
            animation: ripple 3s infinite;
            opacity: 0;
            pointer-events: none;
        }
        @keyframes ripple {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; border-width: 2px; }
            100% { transform: translate(-50%, -50%) scale(6); opacity: 0; border-width: 0px; }
        }

        #loading {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: var(--accent-color);
            font-family: monospace; font-size: 1.2rem; z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 10px var(--accent-color);
        }

        /* --- Updated Card Style (Glassmorphism Deep Sea) --- */
        .node-level-card {
            width: 400px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            overflow: hidden;
            text-align: left;
            /* è“è‰²æŠ•å½± */
            box-shadow: 0 10px 40px rgba(0, 10, 30, 0.8), 0 0 20px rgba(0, 243, 255, 0.1);
            backdrop-filter: blur(12px);
            display: flex;
            flex-direction: column;
        }

        .card-header {
            padding: 0;
            position: relative;
        }
        
        .card-thumb {
            width: 100%;
            height: 100px;
            object-fit: cover;
            display: block;
            opacity: 0.9;
            mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
        }
        
        .card-info {
            padding: 10px 16px;
            border-bottom: 1px solid rgba(0, 243, 255, 0.1);
        }

        .card-title {
            font-size: 1rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px rgba(0, 243, 255, 0.5);
            margin-bottom: 4px;
        }
        
        .card-desc {
            font-size: 0.8rem;
            color: #b0dfff;
            line-height: 1.4;
        }

        /* Outcome List */
        .outcome-list {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .outcome-item {
            background: var(--outcome-bg);
            border-radius: 8px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid transparent;
        }
        
        .outcome-item:hover {
            background: var(--outcome-hover);
            border-color: var(--accent-color);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            transform: translateX(5px);
        }

        .outcome-icon {
            font-size: 1.4rem;
            filter: drop-shadow(0 0 5px var(--accent-color));
        }

        .outcome-text {
            display: flex;
            flex-direction: column;
        }

        .outcome-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
        }
        .outcome-source {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--accent-color);
            margin-bottom: 2px;
            text-transform: uppercase;
        }
        .outcome-sub {
            font-size: 0.75rem;
            color: #8ac0ff;
        }

    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">Diving into Ziqi's World...</div>
    <div id="scene-container"></div>
    <div id="ui-layer"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- Config ---
        const CONFIG = {
            globeRadius: 18, // ç¨å¾®å‡å°ä¸€ç‚¹ï¼Œè®©å®ƒçœ‹èµ·æ¥æ›´åƒä¸€ä¸ªæ‚¬æµ®çš„æ ¸å¿ƒæ°”æ³¡
            colorBg: 0x000510,
            colorLine: 0x00f3ff, // çº¿çš„é¢œè‰²æ”¹ä¸ºäº®é’è‰²
            cameraPos: { x: 0, y: 30, z: 45 }, 
            rootLat: 60  
        };

        // --- Data ---
        const hierarchy = {
            id: 'root', type: 'root', name: 'Ziqi Pan', unit: 'I care about people.',
            lat: CONFIG.rootLat, lon: 0,
            children: [
                {
                    id: 'l1-1', label: 'Me', type: 'level-1', 
                    lat: 20, lon: -60,
                    children: []
                },
                {
                    id: 'l1-2', label: 'Me as\nHCI Researcher', type: 'level-1', 
                    lat: 20, lon: 0, 
                    children: [
                        { id: 'l2-1', label: 'Human-Environment Interaction', type: 'level-2', lat: -10, lon: -25,
                            children: [
                                {
                                    id: 'card-1', 
                                    type: 'level-card',
                                    name: 'Affordance-based Interaction with Everyday Objects', 
                                    desc: 'Exploring new interaction opportunities with everyday objects through understanding and leveraging their affordances.', 
                                    thumb: 'https://via.placeholder.com/300x120',
                                    lat: -25, lon: -40, 
                                    outcomes: [
                                        { source: 'CHI 2025 Paper', title: 'ACKnowledge: A Computational Framework for Human Compatible Affordance-based Interaction Planning', 
                                        link: 'https://scholar.google.com', icon: 'ğŸ“„' },
                                    ]
                                }
                            ]
                        },
                        { id: 'l2-2', label: 'Human-Human Interaction', type: 'level-2', lat: -20, lon: 0,
                            children: [
                                {
                                    id: 'card-2', 
                                    type: 'level-card',
                                    name: 'Online communities and remote collaboration', 
                                    desc: 'Exploring how humans interact and collaborate via AI/technology-aided communication in online communities.', 
                                    thumb: 'https://via.placeholder.com/300x120',
                                    lat: -35, lon: -50, 
                                    outcomes: [
                                        { source: 'CHI 2025 Poster', title: '"I Love the Internet Again": Exploring the Interaction Inception of "TikTok Refugees"', 
                                        link: 'https://scholar.google.com', icon: 'ğŸ“„' },
                                        { source: 'CSCW 2025 Poster', title: 'From Platform Migration to Cultural Integration',
                                        link: 'https://scholar.google.com', icon: 'ğŸ“„' },
                                        { source: 'CHI 2026 Paper', title: 'Women Empowerment',
                                        link: 'https://scholar.google.com', icon: 'ğŸ’»' }
                                    ]
                                },
                                {
                                    id: 'card-3', 
                                    type: 'level-card',
                                    name: 'Robot/Agent shaping Human-Human Interaction', 
                                    desc: 'Exploring how robots or intelligent agents can facilitate and enhance human-human interaction.', 
                                    thumb: 'https://via.placeholder.com/300x120',
                                    lat: -35, lon: 50, 
                                    outcomes: [
                                        { source: 'CHI 2026 LBW', title: 'AnimaStand short', 
                                        link: 'https://scholar.google.com', icon: 'ğŸ“„' },
                                        { source: 'Under Review', title: 'AnimaStand full',
                                        link: 'https://scholar.google.com', icon: 'ğŸ“„' },
                                        { source: 'CHI 2026 Paper', title: 'StarHarvest',
                                        link: 'https://scholar.google.com', icon: 'ğŸ’»' }
                                    ]
                                },
                            ]
                        },
                        { id: 'l2-3', label: 'Human-Self Interaction', type: 'level-2', lat: -10, lon: 25,
                            children: [
                                {
                                    id: 'card-4', 
                                    type: 'level-card',
                                    name: 'Self-reflection and Personal Growth', 
                                    desc: 'Investigating how technology can support self-reflection, mindfulness, and personal growth.', 
                                    thumb: 'https://via.placeholder.com/300x120',
                                    lat: -25, lon: 40, 
                                    outcomes: [
                                        { source: 'CHI 2027 Paper', title: 'MindfulMirror', 
                                        link: 'https://scholar.google.com', icon: 'ğŸ“„' },
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 'l1-3', label: 'Me as\nArtist', type: 'level-1', 
                    lat: 20, lon: 60,
                    children: [
                        { id: 'l2-4', label: 'Dance', type: 'level-2', lat: 10, lon: 80 },
                        { id: 'l2-5', label: 'Music', type: 'level-2', lat: 30, lon: 80 },
                        { id: 'l2-6', label: 'Photography', type: 'level-2', lat: -10, lon: 80 }
                    ]
                }
            ]
        };

        // --- Scene Init ---
        const container = document.getElementById('scene-container');
        const uiLayer = document.getElementById('ui-layer');
        const scene = new THREE.Scene();
        // 1. æ·±æµ·é›¾æ°”
        const loader = new THREE.TextureLoader();
        // è¿™é‡Œæ›¿æ¢ä¸ºä½ æœ¬åœ°å›¾ç‰‡çš„è·¯å¾„ï¼Œä¾‹å¦‚ 'images/sea.jpg'
        // å¦‚æœå›¾ç‰‡åœ¨åŒçº§ç›®å½•ï¼Œç›´æ¥å†™ 'sea.jpg'
        loader.load('./bg3.png', function(texture) {
            texture.colorSpace = THREE.SRGBColorSpace;
            
            // 1. åˆ›å»ºä¸€ä¸ªå·¨å¤§çš„çƒä½“ï¼ŒæŠŠå›¾ç‰‡è´´åœ¨çƒä½“å†…éƒ¨ (BackSide)
            const bgGeometry = new THREE.SphereGeometry(900, 60, 40); // åŠå¾„900ï¼Œè¶³å¤Ÿå¤§ï¼ŒåŒ…ä½æ‰€æœ‰ä¸œè¥¿
            
            // 2. åˆ›å»ºæè´¨
            // color: 0x555555 æ˜¯å…³é”®ï¼
            // å®ƒç›¸å½“äºä¸€ä¸ªæ»¤é•œã€‚0xffffff æ˜¯åŸå›¾äº®åº¦ï¼Œ0x000000 æ˜¯å…¨é»‘ã€‚
            // 0x555555 å¤§çº¦ç›¸å½“äºç›–äº†ä¸€å±‚ 60%-70% çš„é»‘è‰²é®ç½©ã€‚
            // å¦‚æœè§‰å¾—è¿˜å¤ªäº®ï¼Œæ”¹æˆ 0x333333ï¼›å¦‚æœå¤ªæš—ï¼Œæ”¹æˆ 0x888888ã€‚
            const bgMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.BackSide, // è´´åœ¨å†…å£
                color: 0x888888,      // <--- è¿™é‡Œæ§åˆ¶äº®åº¦/é®ç½©æµ“åº¦
                fog: false            // <--- å…³é”®ï¼šä¸è®©æ·±æµ·é›¾æ°”æŠŠèƒŒæ™¯å®Œå…¨å˜é»‘ï¼Œä¿æŒå›¾ç‰‡å¯è§
            });

            const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
            scene.add(bgMesh);
        });
        scene.fog = new THREE.FogExp2(0x001020, 0.012);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(CONFIG.cameraPos.x, CONFIG.cameraPos.y, CONFIG.cameraPos.z);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        // ä½¿ç”¨ ACESFilmic è®©å…‰ç…§æ›´è‡ªç„¶
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 90;
        controls.enablePan = false;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3; // æ…¢ä¸€ç‚¹ï¼Œåƒåœ¨æ°´é‡Œ

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // 2. å¢å¼º Bloom æ•ˆæœï¼Œåˆ¶é€ å‘å…‰çº¿
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 1.2;  // å¢å¼ºè¾‰å…‰
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.2;
        composer.addPass(bloomPass);

        // --- Lights (Deep Sea Atmosphere) ---
        // ç¯å¢ƒå…‰
        const ambientLight = new THREE.AmbientLight(0x001e36, 1.5);
        scene.add(ambientLight);

        // é¡¶éƒ¨ç›´å°„å…‰ï¼ˆæ¨¡æ‹Ÿé˜³å…‰ç©¿é€æµ·é¢ï¼‰
        const sunLight = new THREE.DirectionalLight(0xffffff, 0.5);
        sunLight.position.set(0, 50, 0);
        scene.add(sunLight);

        // å†…éƒ¨å‘å…‰ï¼ˆç‚¹å…‰æºï¼‰- è®©æ°”æ³¡æ ¸å¿ƒå‘äº®
        const innerLight = new THREE.PointLight(0x00f3ff, 3, 50);
        innerLight.position.set(0, 0, 0);
        scene.add(innerLight);

        // --- Objects ---
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);

        // 3. æ›¿æ¢ä¸ºæ°”æ³¡ (Bubble)
        // ä½¿ç”¨ MeshPhysicalMaterial åˆ¶ä½œç»ç’ƒ/æ°´æ³¡è´¨æ„Ÿ
        const bubbleGeometry = new THREE.SphereGeometry(CONFIG.globeRadius, 64, 64);
        const bubbleMaterial = new THREE.MeshPhysicalMaterial({
            // 1. åŸºåº•é¢œè‰²æ”¹ä¸ºææµ…çš„é’ç™½è‰²ï¼Œç”šè‡³æ¥è¿‘ç™½è‰²
            // ä¹‹å‰çš„ 0x88ccff å¤ªæ·±äº†ï¼Œè¿™é‡Œæ”¹æ·¡
            color: 0xeefaff,   
            // 2. é‡‘å±æ„Ÿè®¾ä¸º 0ï¼Œæ°´æ˜¯éé‡‘å±
            metalness: 0,
            // 3. æåº¦å…‰æ»‘ï¼ŒåƒæŠ›å…‰ç»ç’ƒ/æ°´é¢
            roughness: 0.05,
            specularIntensity: 0,        
            // 4. é€å°„ç‡æé«˜åˆ° 0.95 (è®©èƒŒåçš„ä¸œè¥¿èƒ½é€è¿‡æ¥ï¼Œåªç•™ä¸€ç‚¹ç‚¹ä»‹è´¨æ„Ÿ)
            transmission: 0.95,      
            // 5. é™ä½åšåº¦æ„Ÿï¼Œè®©å®ƒçœ‹èµ·æ¥æ›´è½»ç›ˆ
            thickness: 0.5,         
            transparent: true,
            opacity: 1,
            side: THREE.FrontSide, // æ”¹ä¸º FrontSide å‡å°‘æ¸²æŸ“é”™è¯¯ï¼Œæˆ–è€… DoubleSide
            // 6. æ¸…æ¼†å±‚ï¼Œæ¨¡æ‹Ÿæ°´è¡¨é¢çš„é‚£å±‚åå…‰
            clearcoat: 1.0,         
            clearcoatRoughness: 0.1,
            // 7. æ°´çš„ç‰©ç†æŠ˜å°„ç‡
            ior: 1.33,
            // 8. [å¯é€‰] æ·»åŠ ä¸€ç‚¹å‘å…‰ï¼Œè®©è¾¹ç¼˜æœ‰ä¸€åœˆæ·¡æ·¡çš„å¹½å…‰
            emissive: 0x0044aa,
            emissiveIntensity: 0.1
        });
        const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
        earthGroup.add(bubble);

        // å†…éƒ¨ç¨å¾®åŠ ä¸€ä¸ªåªæœ‰çº¿æ¡†çš„çƒï¼Œå¢åŠ å±‚æ¬¡æ„Ÿ
        const innerWire = new THREE.LineSegments(
            new THREE.WireframeGeometry(new THREE.SphereGeometry(CONFIG.globeRadius * 0.95, 24, 24)),
            new THREE.LineBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.05 })
        );
        earthGroup.add(innerWire);


        const noteGroup = new THREE.Group();
        scene.add(noteGroup);

        function createNoteMaterial(char, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; 
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 80px Arial';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // å‘å…‰æ–‡å­—
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;
            ctx.fillText(char, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function initMusicalUniverse() {
            const symbols = ['â™ª', 'â™«', 'â™­', 'â™®', 'â™¯', 'ğ„', 'â—‹', 'â€¢', 'âˆ˜'];
            // æ·±æµ·å‘å…‰è‰²ç³»
            const colors = ['#ffffff', '#00f3ff', '#0077ff', '#bdeeff'];
            const materials = [];

            symbols.forEach(sym => {
                colors.forEach(col => {
                    const tex = createNoteMaterial(sym, col);
                    const mat = new THREE.SpriteMaterial({
                        map: tex,
                        transparent: true,
                        blending: THREE.AdditiveBlending, // åŠ æ³•æ··åˆï¼Œè®©é‡å å¤„æ›´äº®
                        depthWrite: false
                    });
                    materials.push(mat);
                });
            });

            const count = 900; 
            for (let i = 0; i < count; i++) {
                const baseMat = materials[Math.floor(Math.random() * materials.length)];
                const mat = baseMat.clone();
                mat.opacity = 0.3 + Math.random() * 0.7; 

                const sprite = new THREE.Sprite(mat);
                const dist = 30 + Math.random() * 120; // èŒƒå›´ç¨å¾®æ‹‰å¤§
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);

                sprite.position.set(
                    dist * Math.sin(phi) * Math.cos(theta),
                    dist * Math.sin(phi) * Math.sin(theta),
                    dist * Math.cos(phi)
                );

                const size = 1 + Math.random() * 2;
                sprite.scale.set(size, size, 1);

                sprite.userData = {
                    randomOffset: Math.random() * 100,
                    speed: 0.2 + Math.random() * 0.3, // é€Ÿåº¦ç¨æ…¢
                    originalY: sprite.position.y
                };
                noteGroup.add(sprite);
            }
        }
        initMusicalUniverse();

        // --- Logic & Helpers ---
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 90) * (Math.PI / 180);
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));
            return new THREE.Vector3(x, y, z);
        }

        function createCurve(v1, v2) {
            const dist = v1.distanceTo(v2);
            const mid = v1.clone().add(v2).multiplyScalar(0.5).normalize().multiplyScalar(CONFIG.globeRadius + dist * 0.4);
            const curve = new THREE.QuadraticBezierCurve3(v1, mid, v2);
            const points = curve.getPoints(60); // å¢åŠ ç‚¹æ•°è®©æ›²çº¿æ›´å¹³æ»‘
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            // 4. å‘å…‰è¿çº¿æè´¨
            // LineBasicMaterial é…åˆ Bloom å³å¯å‘å…‰ï¼Œå…³é”®æ˜¯é¢œè‰²è¦å¤Ÿäº®
            const material = new THREE.LineBasicMaterial({ 
                color: CONFIG.colorLine, 
                transparent: true, 
                opacity: 0.8,
                linewidth: 2 
            });
            return new THREE.Line(geometry, material);
        }

        const nodesMap = {}; 

        function initNodes(data, parentPos = null) {
            const pos = latLonToVector3(data.lat, data.lon, CONFIG.globeRadius);
            
            const div = document.createElement('div');
            div.className = `node-label node-${data.type}`;
            div.id = `n-${data.id}`;
            
            if (data.type === 'root') {
                div.innerHTML = `<img src="./profile_photo.jpg" class="avatar"><div class="info"><div class="name">${data.name}</div><div class="unit">${data.unit}</div></div>`;
                div.onclick = () => focusNode(data.id);
            } else if (data.type === 'level-1') {
                div.innerHTML = `<div class="dot-l1"></div><div class="text-l1">${data.label.replace(/\n/g, '<br>')}</div>`;
                div.classList.add('ripple');
                div.onclick = (e) => { e.stopPropagation(); toggleNode(data.id); };
            } else if (data.type === 'level-2') {
                div.innerHTML = `<div class="dot-l2"></div><div class="text-l2">${data.label}</div>`;
                div.onclick = (e) => { e.stopPropagation(); toggleNode(data.id); };
            } 
            else if (data.type === 'level-card') {
                let outcomesHtml = '';
                if (data.outcomes && data.outcomes.length > 0) {
                    outcomesHtml = data.outcomes.map(o => `
                        <div class="outcome-item">
                            <div class="outcome-icon" onclick="window.open('${o.link}', '_blank'); event.stopPropagation();">${o.icon || 'ğŸ”—'}</div>
                            <div class="outcome-text">
                                <div class="outcome-source">${o.source}</div>
                                <div class="outcome-title">${o.title}</div>
                                <div class="outcome-sub">${o.authors || ''}</div>
                            </div>
                        </div>
                    `).join('');
                }

                div.innerHTML = `
                    <div class="card-header">
                        <img src="${data.thumb}" class="card-thumb">
                        <div class="card-info">
                            <div class="card-title">${data.name}</div>
                            <div class="card-desc">${data.desc}</div>
                        </div>
                    </div>
                    <div class="outcome-list">
                        ${outcomesHtml}
                    </div>
                `;
                div.onclick = (e) => { e.stopPropagation(); focusNode(data.id); };
            }
            
            uiLayer.appendChild(div);

            const nodeObj = {
                id: data.id,
                data: data,
                posLocal: pos,
                element: div,
                visible: (data.type === 'root' || data.type === 'level-1'), 
                expanded: false,
                childrenIds: data.children ? data.children.map(c => c.id) : [],
                lineMesh: null
            };

            if (parentPos) {
                const line = createCurve(parentPos, pos);
                earthGroup.add(line);
                nodeObj.lineMesh = line;
                if (data.type !== 'level-1') line.visible = false;
            }

            nodesMap[data.id] = nodeObj;

            if (data.children) data.children.forEach(c => initNodes(c, pos));
        }

        initNodes(hierarchy);
        document.getElementById('loading').style.display = 'none';

        function hideDescendants(parentNode) {
            if (!parentNode.childrenIds || parentNode.childrenIds.length === 0) return;
            parentNode.childrenIds.forEach(childId => {
                const child = nodesMap[childId];
                child.visible = false;
                child.expanded = false; 
                if (child.lineMesh) child.lineMesh.visible = false;
                hideDescendants(child);
            });
        }

        function toggleNode(nodeId) {
            const node = nodesMap[nodeId];
            
            if (node.data.type === 'level-1' && !node.expanded) {
                for (const key in nodesMap) {
                    const otherNode = nodesMap[key];
                    if (otherNode.data.type === 'level-1' && otherNode.expanded && otherNode.id !== node.id) {
                        otherNode.expanded = false;
                        hideDescendants(otherNode); 
                    }
                }
            }

            if (node.data.type === 'level-2' && !node.expanded) {
                for (const key in nodesMap) {
                    const otherNode = nodesMap[key];
                    if (otherNode.data.type === 'level-2' && otherNode.expanded && otherNode.id !== node.id) {
                        otherNode.expanded = false;     
                        hideDescendants(otherNode);    
                    }
                }
            }

            node.expanded = !node.expanded;

            if (node.expanded) {
                node.childrenIds.forEach(childId => {
                    const child = nodesMap[childId];
                    child.visible = true;
                    if (child.lineMesh) child.lineMesh.visible = true;
                });
            } else {
                hideDescendants(node);
            }

            focusNode(nodeId);
        }

        function focusNode(nodeId) {
            const node = nodesMap[nodeId];
            if(!node) return;

            controls.autoRotate = false;
            const currentDist = camera.position.distanceTo(new THREE.Vector3(0,0,0));
            const targetLat = node.data.lat - 30; 
            const targetLon = node.data.lon;

            const targetPos = latLonToVector3(targetLat, targetLon, currentDist);

            new TWEEN.Tween(camera.position)
                .to({ x: targetPos.x, y: targetPos.y, z: targetPos.z }, 1000)
                .easing(TWEEN.Easing.Cubic.Out)
                .onUpdate(() => controls.update())
                .start();
            
            document.querySelectorAll('.node-label').forEach(el => el.classList.add('faded'));
            node.element.classList.remove('faded');
            if(node.childrenIds) {
                node.childrenIds.forEach(cid => {
                    const child = nodesMap[cid];
                    if(child.visible) child.element.classList.remove('faded');
                });
            }
        }

        window.addEventListener('mousedown', (e) => {
            if(e.target.id === 'ui-layer') {
                document.querySelectorAll('.node-label').forEach(el => el.classList.remove('faded'));
                controls.autoRotate = true;
            }
        });

        // --- Animation Loop ---
        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();

            // 5. æ°”æ³¡å‘¼å¸åŠ¨ç”» (Breathing Animation)
            // åˆ©ç”¨ sin å‡½æ•°è®©æ°”æ³¡è½»å¾®ç¼©æ”¾
            const breathingScale = 1 + Math.sin(time * 0.0008) * 0.015;
            bubble.scale.setScalar(breathingScale);

            // ç²’å­æ—‹è½¬ä¸æµ®åŠ¨
            noteGroup.rotation.y += 0.0003; 
            noteGroup.children.forEach((sprite, index) => {
                sprite.material.opacity = 0.4 + Math.sin(time * 0.002 + index) * 0.2;
                // æ·»åŠ è½»å¾®çš„ä¸Šä¸‹æµ®åŠ¨
                sprite.position.y = sprite.userData.originalY + Math.sin(time * 0.001 + index) * 0.5;
            });

            for (const key in nodesMap) {
                const node = nodesMap[key];
                
                if (!node.visible) {
                    node.element.style.transform = `translate(-10000px, -10000px)`;
                    node.element.style.opacity = 0;
                    continue; 
                }

                const worldPos = node.posLocal.clone();
                // å¦‚æœæ°”æ³¡åœ¨ç¼©æ”¾ï¼ŒèŠ‚ç‚¹ä½ç½®ä¹Ÿåº”è¯¥è·Ÿç€è½»å¾®ç§»åŠ¨ï¼Œæˆ–è€…è¿™é‡Œä¿æŒä¸å˜ä¹Ÿå¯ä»¥
                worldPos.applyMatrix4(earthGroup.matrixWorld);

                const isBehind = worldPos.angleTo(camera.position) > Math.PI / 2.1; 

                if (!isBehind) {
                    worldPos.project(camera);
                    const x = (worldPos.x * .5 + .5) * window.innerWidth;
                    const y = (worldPos.y * -.5 + .5) * window.innerHeight;
                    
                    const anchor = (node.data.type === 'level-card') ? 'translate(-50%, 0)' : 'translate(-50%, -50%)';
                    node.element.style.transform = `${anchor} translate(${x}px, ${y}px)`;
                    
                    if (node.element.style.opacity === '0') {
                         node.element.style.opacity = 1; 
                    } else if (node.element.style.opacity === '') {
                        node.element.style.opacity = 1;
                    }
                } else {
                    node.element.style.opacity = 0;
                    node.element.style.transform = `translate(-10000px, -10000px)`; 
                }
            }
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        controls.addEventListener('start', () => { controls.autoRotate = false; });

        animate();

    </script>
</body>
</html>